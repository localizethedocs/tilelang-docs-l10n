# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025-2025, Tile Lang Contributors
# This file is distributed under the same license as the Tile Language <br> package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TileLang <br> stable\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-14 17:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:2
msgid "tilelang.quantize.lop3"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:8
msgid "Attributes"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ":py:obj:`decode_i4_to_f16 <tilelang.quantize.lop3.decode_i4_to_f16>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale <tilelang.quantize.lop3."
"decode_i4_to_f16_scale>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_offset <tilelang.quantize.lop3."
"decode_i4_to_f16_scale_offset>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_zeros_original <tilelang.quantize.lop3."
"decode_i4_to_f16_scale_zeros_original>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_zeros_original_offset <tilelang.quantize."
"lop3.decode_i4_to_f16_scale_zeros_original_offset>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_zeros_rescale <tilelang.quantize.lop3."
"decode_i4_to_f16_scale_zeros_rescale>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_zeros_rescale_offset <tilelang.quantize.lop3."
"decode_i4_to_f16_scale_zeros_rescale_offset>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_zeros_quantized <tilelang.quantize.lop3."
"decode_i4_to_f16_scale_zeros_quantized>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4_to_f16_scale_zeros_quantized_offset <tilelang.quantize."
"lop3.decode_i4_to_f16_scale_zeros_quantized_offset>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ":py:obj:`decode_i2_to_f16 <tilelang.quantize.lop3.decode_i2_to_f16>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2_to_f16_scale <tilelang.quantize.lop3."
"decode_i2_to_f16_scale>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2_to_f16_scale_zeros_original_offset <tilelang.quantize."
"lop3.decode_i2_to_f16_scale_zeros_original_offset>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2_to_f16_scale_zeros_original <tilelang.quantize.lop3."
"decode_i2_to_f16_scale_zeros_original>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2_to_f16_scale_zeros_rescale <tilelang.quantize.lop3."
"decode_i2_to_f16_scale_zeros_rescale>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2_to_f16_scale_zeros_quantized <tilelang.quantize.lop3."
"decode_i2_to_f16_scale_zeros_quantized>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ":py:obj:`decode_i1_to_f16 <tilelang.quantize.lop3.decode_i1_to_f16>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i1_to_f16_scale <tilelang.quantize.lop3."
"decode_i1_to_f16_scale>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i1_to_f16_scale_zeros_original <tilelang.quantize.lop3."
"decode_i1_to_f16_scale_zeros_original>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i1_to_f16_scale_zeros_rescale <tilelang.quantize.lop3."
"decode_i1_to_f16_scale_zeros_rescale>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i1s_to_i8s <tilelang.quantize.lop3.decode_i1s_to_i8s>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2s_to_i8s <tilelang.quantize.lop3.decode_i2s_to_i8s>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i4s_to_i8s <tilelang.quantize.lop3.decode_i4s_to_i8s>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:36:<autosummary>:1
msgid ""
":py:obj:`decode_i2s_to_i4s <tilelang.quantize.lop3.decode_i2s_to_i4s>`\\"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:38
msgid "Functions"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:44:<autosummary>:1
msgid ""
":py:obj:`get_lop3_intrin_group <tilelang.quantize.lop3."
"get_lop3_intrin_group>`\\ \\(out\\_dtype\\[\\, source\\_format\\, ...\\]\\)"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:44:<autosummary>:1
msgid ""
"This function is used to get the intrinsic group of the LOP3 operation to "
"avoid the overhead of fast decoding."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:46
msgid "Module Contents"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:51
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:101
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:158
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:226
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:283
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:353
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:408
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:476
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:530
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:604
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:660
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:717
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:789
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:841
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:893
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:949
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1033
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1112
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1168
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1223
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1295
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1359
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1424
msgid "<details><summary>Show Value</summary>"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:55
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, bool isSigned = false>\n"
"__device__ void decode_i4b_to_f16(T1 *_i4s, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i4s_to_f16(T1 *_i4s, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    decode_i4b_to_f16<T1, T2, true>(_i4s, B_local_decode, N);\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i4u_to_f16(T1 *_i4u, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    decode_i4b_to_f16<T1, T2, false>(_i4u, B_local_decode, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:92
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:149
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:217
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:274
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:344
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:399
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:467
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:521
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:595
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:651
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:708
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:780
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:832
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:884
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:940
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1024
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1103
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1159
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1214
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1286
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1350
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1415
#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1471
msgid "</details>"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:105
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false, bool "
"withScaling = false>\n"
"__device__ void decode_i4b_to_f16_scale(T1 *_i4s, T2 *B_local_decode, const "
"int N = 8, const T3 *scale = nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i4s_to_f16_scale(T1 *_i4s, T2 *B_local_decode, T3 "
"*scale = nullptr, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale<T1, T2, T3, true, true>(_i4s, B_local_decode, N, "
"scale);\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i4u_to_f16_scale(T1 *_i4u, T2 *B_local_decode, T3 "
"*scale = nullptr, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale<T1, T2, T3, false, true>(_i4u, B_local_decode, "
"N, scale);\n"
"}\n"
"\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:162
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false, bool "
"withScaling = false>\n"
"__device__ void decode_i4b_to_f16_scale_offset(T1 *_i4s, T2 *B_local_decode, "
"const int N = 8, const T3 *scale = nullptr, const int offset = 0)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_l = *scale;\n"
"    T3 const scale_r = *(scale + offset);\n"
"    uint const packed_scales_l = __pack_half2(scale_l, scale_l);\n"
"    uint const packed_scales_r = __pack_half2(scale_r, scale_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"    }\n"
"    #pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_l), \"r\"(0));\n"
"    }\n"
"#pragma unroll\n"
"    for (int i = (N / 4); i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_r), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i4s_to_f16_scale_offset(T1 *_i4s, T2 *B_local_decode, "
"T3 *scale = nullptr, const int offset = 0, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale_offset<T1, T2, T3, true, true>(_i4s, "
"B_local_decode, N, scale, offset);\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i4u_to_f16_scale_offset(T1 *_i4u, T2 *B_local_decode, "
"T3 *scale = nullptr, const int offset = 0, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale_offset<T1, T2, T3, false, true>(_i4u, "
"B_local_decode, N, scale, offset);\n"
"}\n"
"\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:230
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i4b_to_f16_zeros_original(T1 *_i4s, T2 "
"*B_local_decode, const int N = 8, const T3 *scale = nullptr, const T4 *zeros "
"= nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"    // input zeros maybe int32(qzeros) or half format\n"
"    T4 const zero_r = *zeros;\n"
"    uint const packed_zeros = __pack_half2(zero_r, zero_r);\n"
"\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_zeros));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i4u_to_f16_scale_zeros_original(T1 *_i4u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_zeros_original<T1, T2, T3, T4, false>(_i4u, "
"B_local_decode, N, scale, zeros);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:287
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i4b_to_f16_zeros_original_offset(T1 *_i4s, T2 "
"*B_local_decode, const int N = 8, const T3 *scale = nullptr, const T4 *zeros "
"= nullptr, const int offset = 0)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_l = *scale;\n"
"    T3 const scale_r = *(scale + offset);\n"
"    uint const packed_scales_l = __pack_half2(scale_l, scale_l);\n"
"    uint const packed_scales_r = __pack_half2(scale_r, scale_r);\n"
"    // input zeros maybe int32(qzeros) or half format\n"
"    T3 const zeros_l = *zeros;\n"
"    T3 const zeros_r = *(zeros + offset);\n"
"    uint const packed_zeros_l = __pack_half2(zeros_l, zeros_l);\n"
"    uint const packed_zeros_r = __pack_half2(zeros_r, zeros_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"    }\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_zeros_l));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_l), \"r\"(0));\n"
"    }\n"
"#pragma unroll\n"
"    for (int i = (N / 4); i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_zeros_r));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_r), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i4u_to_f16_scale_zeros_original_offset(T1 *_i4u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int offset "
"= 0, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_zeros_original_offset<T1, T2, T3, T4, false>(_i4u, "
"B_local_decode, N, scale, zeros, offset);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:357
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i4b_to_f16_scale_zeros_rescale(T1 *_i4s, T2 "
"*B_local_decode, const int N = 8, const T3 *scale = nullptr, const T4 *zeros "
"= nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"    T4 const zero_r = *zeros;\n"
"    uint const packed_zeros = 0x80008000 | __pack_half2(zero_r, zero_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(packed_zeros));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i4u_to_f16_scale_zeros_rescale(T1 *_i4u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale_zeros_rescale<T1, T2, T3, T4, false>(_i4u, "
"B_local_decode, N, scale, zeros);\n"
"}\n"
"\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:412
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i4b_to_f16_scale_zeros_rescale_offset(T1 *_i4s, T2 "
"*B_local_decode, const int N = 8, const T3 *scale = nullptr, const T4 *zeros "
"= nullptr, const int offset = 0)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64086408 : 0x64006400;\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_l = *scale;\n"
"    T3 const scale_r = *(scale + offset);\n"
"    uint const packed_scales_l = __pack_half2(scale_l, scale_l);\n"
"    uint const packed_scales_r = __pack_half2(scale_r, scale_r);\n"
"    // input zeros maybe int32(qzeros) or half format\n"
"    T3 const zeros_l = *zeros;\n"
"    T3 const zeros_r = *(zeros + offset);\n"
"    uint const packed_zeros_l = 0x80008000 | __pack_half2(zeros_l, "
"zeros_l);\n"
"    uint const packed_zeros_r = 0x80008000 | __pack_half2(zeros_r, "
"zeros_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"    }\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_l), \"r\"(packed_zeros_l));\n"
"    }\n"
"#pragma unroll\n"
"    for (int i = (N / 4); i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_r), \"r\"(packed_zeros_r));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i4u_to_f16_scale_zeros_rescale_offset(T1 *_i4u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int offset "
"= 0, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale_zeros_rescale_offset<T1, T2, T3, T4, "
"false>(_i4u, B_local_decode, N, scale, zeros, offset);\n"
"}\n"
"\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:480
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i4b_to_f16_scale_zeros_quantized(T1 *_i4s, T2 "
"*B_local_decode, const int N = 8, const T3 *scale = nullptr, const T4 *zeros "
"= nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"    // input zeros maybe int32(qzeros) or half format\n"
"    int16_t const zero_r = *((int16_t*)zeros);\n"
"    uint median_num = ((0xe400 | zero_r) << 16) | (0xe400 | zero_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(median_num));\n"
"\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename storage_dtype, typename target_dtype, typename "
"scale_dtype, typename zero_dtype>\n"
"__device__ void decode_i4u_to_f16_scale_zeros_quantized(storage_dtype *_i4u, "
"target_dtype *B_local_decode, scale_dtype *scale = nullptr, zero_dtype "
"*zeros = nullptr, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale_zeros_quantized<storage_dtype, target_dtype, "
"scale_dtype, zero_dtype, false>(_i4u, B_local_decode, N, scale, zeros);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:534
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false>\n"
"__device__ void decode_i4b_to_f16_scale_zeros_quantized_offset(T1 *_i4s, T2 "
"*B_local_decode, const int N = 8, const T3 *scale = nullptr, const T1 "
"*qzeros = nullptr, const int scale_offset = 0, const int qzeros_offset = 0, "
"const int group_offset = 0)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x000f000f;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    // Minus 7 to scale the value to signed\n"
"    uint const i4s = *reinterpret_cast<uint *>(_i4s);\n"
"\n"
"    T3 const scale_l = *scale;\n"
"    T3 const scale_r = *(scale + scale_offset);\n"
"    uint const packed_scales_l = __pack_half2(scale_l, scale_l);\n"
"    uint const packed_scales_r = __pack_half2(scale_r, scale_r);\n"
"\n"
"    const int num_elems_per_storage_dtype = sizeof(T1) * 8 / 4;\n"
"\n"
"    T1 const qzeros_l = *qzeros;\n"
"    T1 const qzeros_r = *(qzeros + qzeros_offset);\n"
"    int16_t const zero_l = (qzeros_l >> (group_offset * 4) & 0xf);\n"
"    int16_t const zero_r = (qzeros_r >> (group_offset * 4) & 0xf);\n"
"\n"
"    uint median_num_l = ((0xe400 | zero_l) << 16) | (0xe400 | zero_l);\n"
"    uint median_num_r = ((0xe400 | zero_r) << 16) | (0xe400 | zero_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i4s >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"    }\n"
"    #pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(median_num_l));\n"
"\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_l), \"r\"(0));\n"
"    }\n"
"#pragma unroll\n"
"    for (int i = (N / 4); i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(median_num_r));\n"
"\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_r), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename storage_dtype, typename target_dtype, typename "
"scale_dtype>\n"
"__device__ void decode_i4u_to_f16_scale_zeros_quantized_offset(storage_dtype "
"*_i4u, target_dtype *B_local_decode, scale_dtype *scale = nullptr, "
"storage_dtype *qzeros = nullptr, const int scale_offset = 0, const int "
"zero_offset = 0, const int group_offset = 0, const int N = 8)\n"
"{\n"
"    decode_i4b_to_f16_scale_zeros_quantized_offset<storage_dtype, "
"target_dtype, scale_dtype, false>(_i4u, B_local_decode, N, scale, qzeros, "
"scale_offset, zero_offset, group_offset);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:608
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, bool isSigned = false>\n"
"__device__ void decode_i2b_to_f16(T1 *_i2s, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00030003;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64026402 : 0x64006400;\n"
"    int16_t const i2s_i16 = *reinterpret_cast<int16_t *>(_i2s);\n"
"    // decode 2 elems at one time.\n"
"    // interleave {e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode for {x,x,x,x,e7,e5,e3,e1,x,x,x,x,e6,e4,e2,e0}\n"
"    // otherwise the pointer of _i2s should be moved to\n"
"    int i2s = (i2s_i16 & 0x00ff);\n"
"    i2s |= ((i2s_i16 & 0xff00) << 8);\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i2s >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i2s_to_f16(T1 *_i2s, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    decode_i2b_to_f16<T1, T2, true>(_i2s, B_local_decode, N);\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i2u_to_f16(T1 *_i2u, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    decode_i2b_to_f16<T1, T2, false>(_i2u, B_local_decode, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:664
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false>\n"
"__device__ void decode_i2b_to_f16_scale(T1 *_i2s, T2 *B_local_decode, T3 "
"*scale = nullptr, const int N = 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00030003;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64026402 : 0x64006400;\n"
"    int16_t const i2s_i16 = *reinterpret_cast<int16_t *>(_i2s);\n"
"    // decode 2 elems at one time.\n"
"    // interleave {e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode for {x,x,x,x,e7,e5,e3,e1,x,x,x,x,e6,e4,e2,e0}\n"
"    // otherwise the pointer of _i2s should be moved to\n"
"    int i2s = (i2s_i16 & 0x00ff);\n"
"    i2s |= ((i2s_i16 & 0xff00) << 8);\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i2s >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*scale, *scale)), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i2s_to_f16_scale(T1 *_i2s, T2 *B_local_decode, T3 "
"*scale, const int N = 8)\n"
"{\n"
"    decode_i2b_to_f16_scale<T1, T2, T3, true>(_i2s, B_local_decode, scale, "
"N);\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i2u_to_f16_scale(T1 *_i2u, T2 *B_local_decode,  T3 "
"*scale, const int N = 8)\n"
"{\n"
"    decode_i2b_to_f16_scale<T1, T2, T3, false>(_i2u, B_local_decode, scale, "
"N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:721
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false>\n"
"__device__ void decode_i2b_to_f16_scale_zeros_original_offset(T1 *_i2s, T2 "
"*B_local_decode, T3 *scale = nullptr, T3 *zeros = nullptr, const int offset "
"= 0, const int N = 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00030003;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64026402 : 0x64006400;\n"
"    int16_t const i2s_i16 = *reinterpret_cast<int16_t *>(_i2s);\n"
"    // decode 2 elems at one time.\n"
"    // interleave {e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode for {x,x,x,x,e7,e5,e3,e1,x,x,x,x,e6,e4,e2,e0}\n"
"    // otherwise the pointer of _i2s should be moved to\n"
"    int i2s = (i2s_i16 & 0x00ff);\n"
"    i2s |= ((i2s_i16 & 0xff00) << 8);\n"
"\n"
"    T3 const zeros_l = *zeros;\n"
"    T3 const zeros_r = *(zeros + offset);\n"
"    uint const packed_zeros_l = __pack_half2(zeros_l, zeros_l);\n"
"    uint const packed_zeros_r = __pack_half2(zeros_r, zeros_r);\n"
"\n"
"    T3 const scale_l = *scale;\n"
"    T3 const scale_r = *(scale + offset);\n"
"    uint const packed_scales_l = __pack_half2(scale_l, scale_l);\n"
"    uint const packed_scales_r = __pack_half2(scale_r, scale_r);\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i2s >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"    }\n"
"    #pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_zeros_l));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_l), \"r\"(0));\n"
"    }\n"
"#pragma unroll\n"
"    for (int i = (N / 4); i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_zeros_r));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales_r), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i2u_to_f16_scale_zeros_original_offset(T1 *_i2u, T2 "
"*B_local_decode,  T3 *scale, T3 *zeros, const int offset = 0, const int N = "
"8)\n"
"{\n"
"    decode_i2b_to_f16_scale_zeros_original<T1, T2, T3, false>(_i2u, "
"B_local_decode, scale, zeros, offset, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:793
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false>\n"
"__device__ void decode_i2b_to_f16_scale_zeros_original(T1 *_i2s, T2 "
"*B_local_decode, T3 *scale = nullptr, T3 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00030003;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64026402 : 0x64006400;\n"
"    int16_t const i2s_i16 = *reinterpret_cast<int16_t *>(_i2s);\n"
"    // decode 2 elems at one time.\n"
"    // interleave {e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode for {x,x,x,x,e7,e5,e3,e1,x,x,x,x,e6,e4,e2,e0}\n"
"    // otherwise the pointer of _i2s should be moved to\n"
"    int i2s = (i2s_i16 & 0x00ff);\n"
"    i2s |= ((i2s_i16 & 0xff00) << 8);\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i2s >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*zeros, *zeros)));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*scale, *scale)), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i2u_to_f16_scale_zeros_original(T1 *_i2u, T2 "
"*B_local_decode,  T3 *scale, T3 *zeros, const int N = 8)\n"
"{\n"
"    decode_i2b_to_f16_scale_zeros_original<T1, T2, T3, false>(_i2u, "
"B_local_decode, scale, zeros, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:845
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, bool isSigned = false>\n"
"__device__ void decode_i2b_to_f16_scale_zeros_rescale(T1 *_i2s, T2 "
"*B_local_decode, T3 *scale = nullptr, T3 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00030003;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64026402 : 0x64006400;\n"
"    int16_t const i2s_i16 = *reinterpret_cast<int16_t *>(_i2s);\n"
"    // decode 2 elems at one time.\n"
"    // interleave {e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode for {x,x,x,x,e7,e5,e3,e1,x,x,x,x,e6,e4,e2,e0}\n"
"    // otherwise the pointer of _i2s should be moved to\n"
"    int i2s = (i2s_i16 & 0x00ff);\n"
"    i2s |= ((i2s_i16 & 0xff00) << 8);\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i2s >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*scale, *scale)), \"r\"(0));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*zeros, *zeros)));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i2u_to_f16_scale_zeros_rescale(T1 *_i2u, T2 "
"*B_local_decode,  T3 *scale, T3 *zeros, const int N = 8)\n"
"{\n"
"    decode_i2b_to_f16_scale_zeros_rescale<T1, T2, T3, false>(_i2u, "
"B_local_decode, scale, zeros, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:897
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i2b_to_f16_scale_zeros_quantized(T1 *_i2s, T2 "
"*B_local_decode, const int N = 8, T3 *scale = nullptr, T4 *zeros = nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00030003;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64016401 : 0x64006400;\n"
"    int16_t const i2s_i16 = *reinterpret_cast<int16_t *>(_i2s);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"    int16_t const zero_r = *((int16_t*)zeros);\n"
"    uint median_num = ((0xe400 | zero_r) << 16) | (0xe400 | zero_r);\n"
"\n"
"    // decode 2 elems at one time.\n"
"    // interleave {e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode for {x,x,x,x,e7,e5,e3,e1,x,x,x,x,e6,e4,e2,e0}\n"
"    // otherwise the pointer of _i2s should be moved to\n"
"    int i2s = (i2s_i16 & 0x00ff);\n"
"    i2s |= ((i2s_i16 & 0xff00) << 8);\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i2s >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(median_num));\n"
"\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i2u_to_f16_scale_zeros_quantized(T1 *_i2u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    decode_i2b_to_f16_scale_zeros_quantized<T1, T2, T3, T4, false>(_i2u, "
"B_local_decode, N, scale, zeros);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:953
msgid ""
"\"\"\"\n"
"/*\n"
"Kind 0: original\n"
"Kind 1: rescale\n"
"Kind 2: quantized\n"
"# documents for zeros_mode:\n"
"# original: target = (dequantize_weight - zero_point) * scale\n"
"# rescale: target = dequantize_weight * scale - zero_point\n"
"# quantized: target = (dequantize_weight - dequantize_zeros) * scale\n"
"# Notice: only support \"original\" and \"rescale\" now\n"
"zeros_mode: Literal[\"original\", \"rescale\", \"quantized\"] = "
"\"original\"\n"
"*/\n"
"template <typename T1, typename T2, bool isSigned = false, bool withScaling "
"= false, bool withZeros = false, int ZerosKind = 1>\n"
"__device__ void decode_i1b_to_f16(T1 *_i1s, T2 *B_local_decode, const int N "
"= 8, half *scale = nullptr, half *zeros = nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00010001;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x64006400 : 0x64006400;\n"
"    static constexpr uint TRANSFORM_SUBTRACT = 0xbc00bc00; // for signed int "
"2x - 1\n"
"    // interleave {e31,e29,e27,e25,e23,e21,e19,e17,e15,e13,e11,e9,e7,e5,e3,"
"e1,e30,e28,e26,e24,e22,e20,e18,e16,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode e7,e5,e3,e1,e8,e6,e4,e2,e0\n"
"    int8_t const i1s_i16 = *reinterpret_cast<int8_t *>(_i1s);\n"
"    int i1s = (i1s_i16 & 0x0f);\n"
"    i1s |= ((i1s_i16 & 0xf0) << 12);\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i1s >> (1 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        if constexpr (isSigned)\n"
"        {\n"
"            asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(h[i]));\n"
"            asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(TRANSFORM_SUBTRACT));\n"
"        }\n"
"        if constexpr (withZeros && ZerosKind == 0)\n"
"        {\n"
"            asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*zeros, *zeros)));\n"
"        }\n"
"        if constexpr (withScaling)\n"
"        {\n"
"            asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : "
"\"=r\"(h[i]) : \"r\"(h[i]), \"r\"(__pack_half2(*scale, *scale)), \"r\"(0));\n"
"        }\n"
"        if constexpr (withZeros && ZerosKind == 1)\n"
"        {\n"
"            asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(__pack_half2(*zeros, *zeros)));\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i1s_to_f16(T1 *_i1s, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    decode_i1b_to_f16<T1, T2, true>(_i1s, B_local_decode, N);\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i1u_to_f16(T1 *_i1u, T2 *B_local_decode, const int N "
"= 8)\n"
"{\n"
"    decode_i1b_to_f16<T1, T2, false>(_i1u, B_local_decode, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1037
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i1u_to_f16_scale(T1 *_i1s, T2 *B_local_decode, T3 "
"*scale = nullptr, const int N = 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00010001;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = 0x64006400;\n"
"    // interleave {e31,e29,e27,e25,e23,e21,e19,e17,e15,e13,e11,e9,e7,e5,e3,"
"e1,e30,e28,e26,e24,e22,e20,e18,e16,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode e7,e5,e3,e1,e8,e6,e4,e2,e0\n"
"    int8_t const i1s_i16 = *reinterpret_cast<int8_t *>(_i1s);\n"
"    int i1s = (i1s_i16 & 0x0f);\n"
"    i1s |= ((i1s_i16 & 0xf0) << 12);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i1s >> (1 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3>\n"
"__device__ void decode_i1s_to_f16_scale(T1 *_i1s, T2 *B_local_decode, T3 "
"*scale = nullptr, const int N = 8)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00010001;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = 0x64006400;\n"
"    static constexpr uint TRANSFORM_SUBTRACT = 0xbc00bc00; // for signed int "
"2x - 1\n"
"    // interleave {e31,e29,e27,e25,e23,e21,e19,e17,e15,e13,e11,e9,e7,e5,e3,"
"e1,e30,e28,e26,e24,e22,e20,e18,e16,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode e7,e5,e3,e1,e8,e6,e4,e2,e0\n"
"\n"
"    int8_t const i1s_i16 = *reinterpret_cast<int8_t *>(_i1s);\n"
"    int i1s = (i1s_i16 & 0x0f);\n"
"    i1s |= ((i1s_i16 & 0xf0) << 12);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i1s >> (1 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(h[i]));\n"
"        asm volatile(\"add.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(TRANSFORM_SUBTRACT));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1116
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i1b_to_f16_zeros_original(T1 *_i1s, T2 "
"*B_local_decode, const int N = 8, T3 *scale = nullptr, T4 *zeros = nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00010001;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = 0x64006400;\n"
"    // interleave {e31,e29,e27,e25,e23,e21,e19,e17,e15,e13,e11,e9,e7,e5,e3,"
"e1,e30,e28,e26,e24,e22,e20,e18,e16,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode e7,e5,e3,e1,e8,e6,e4,e2,e0\n"
"    int8_t const i1s_i16 = *reinterpret_cast<int8_t *>(_i1s);\n"
"    int i1s = (i1s_i16 & 0x0f);\n"
"    i1s |= ((i1s_i16 & 0xf0) << 12);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"    // input zeros maybe int32(qzeros) or half format\n"
"    T4 const zero_r = *zeros;\n"
"    uint const packed_zeros = __pack_half2(zero_r, zero_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i1s >> (1 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_zeros));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(0));\n"
"    }\n"
"}\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i1u_to_f16_scale_zeros_original(T1 *_i1u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    decode_i1b_to_f16_zeros_original<T1, T2, T3, T4, false>(_i1u, "
"B_local_decode, N, scale, zeros);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1172
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, typename T3, typename T4, bool isSigned "
"= false>\n"
"__device__ void decode_i1b_to_f16_scale_zeros_rescale(T1 *_i1s, T2 "
"*B_local_decode, const int N = 8, T3 *scale = nullptr, T4 *zeros = nullptr)\n"
"{\n"
"    uint *h = reinterpret_cast<uint *>(B_local_decode);\n"
"\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x00010001;\n"
"    static constexpr uint FP16_TOP_MAGIC_NUM = 0x64006400;\n"
"    static constexpr uint MEDIAN_NUM = 0x64006400;\n"
"    // interleave {e31,e29,e27,e25,e23,e21,e19,e17,e15,e13,e11,e9,e7,e5,e3,"
"e1,e30,e28,e26,e24,e22,e20,e18,e16,e14,e12,e10,e8,e6,e4,e2,e0}\n"
"    // only decode e7,e5,e3,e1,e8,e6,e4,e2,e0\n"
"    int8_t const i1s_i16 = *reinterpret_cast<int8_t *>(_i1s);\n"
"    int i1s = (i1s_i16 & 0x0f);\n"
"    i1s |= ((i1s_i16 & 0xf0) << 12);\n"
"    T3 const scale_r = *scale;\n"
"    uint const packed_scales = __pack_half2(scale_r, scale_r);\n"
"    T4 const zero_r = *zeros;\n"
"    uint const packed_zeros = 0x80008000 | __pack_half2(zero_r, zero_r);\n"
"\n"
"#pragma unroll\n"
"    // decode 2 elems at one time.\n"
"    for (int i = 0; i < (N / 2); i++)\n"
"    {\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(h[i])\n"
"                     : \"r\"(i1s >> (1 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(FP16_TOP_MAGIC_NUM), \"n\"(immLut));\n"
"        asm volatile(\"sub.f16x2 %0, %1, %2;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(MEDIAN_NUM));\n"
"        asm volatile(\"fma.rn.f16x2 %0, %1, %2, %3;\\n\" : \"=r\"(h[i]) : "
"\"r\"(h[i]), \"r\"(packed_scales), \"r\"(packed_zeros));\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2, typename T3, typename T4>\n"
"__device__ void decode_i1u_to_f16_scale_zeros_rescale(T1 *_i4u, T2 "
"*B_local_decode, T3 *scale = nullptr, T4 *zeros = nullptr, const int N = 8)\n"
"{\n"
"    decode_i1b_to_f16_scale_zeros_rescale<T1, T2, T3, T4, false>(_i4u, "
"B_local_decode, N, scale, zeros);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1227
msgid ""
"\"\"\"template <typename T1, typename T2>\n"
"__device__ void decode_i1s_to_i8s(T1 *_i1b, T2 *_i8s, const int N = 16)\n"
"{\n"
"    int i8s[4];\n"
"    // vector load\n"
"    *reinterpret_cast<int4 *>(i8s) = *reinterpret_cast<int4 *>(_i8s);\n"
"    int16_t i1b_i16 = *reinterpret_cast<int16_t *>(_i1b);\n"
"    // permutate: {e0,e4,e8,e12,e2,e6,e10,e14,e1,e5,e9,e13,e3,e7,e11,e15}\n"
"    // into: {e0,e4,e8,e12,x,x,x,x,e1,e5,e9,x,x,x,x,e13,e2,e6,e10,e14,e1,e5,"
"e9,e13,e3,e7,e11,e15,x,x,x,x}\n"
"    int i1b = (i1b_i16 & 0x0f0f);\n"
"    i1b |= ((i1b_i16 & 0xf0f0) << 12);\n"
"    // i1b        {0..,e15,e14,e13,e12,e11,e10,e9,e8,e7,e6,e5,e4,e3,e2,e1,"
"e0}\n"
"    // interleave {0..,e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,"
"e0}\n"
"    // First, we extract the i1b and construct an intermediate fp16 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa; // 0b11101010\n"
"    static constexpr uint BOTTOM_MASK = 0x01010101;      // 0x1 -> 0b01 "
"select 0,1\n"
"    static constexpr uint I8s_MAGIC_NUM = 0x00000000;\n"
"    static constexpr uint TRANSFORM_SUBTRACT = 0xffffffff; // for signed int "
"2x - 1\n"
"\n"
"    for (int i = 0; i < N / 4; i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i])\n"
"                     : \"r\"(i1b >> i), \"n\"(BOTTOM_MASK), "
"\"n\"(I8s_MAGIC_NUM), \"n\"(immLut));\n"
"        i8s[i] = __vadd4(i8s[i], i8s[i]);\n"
"        i8s[i] = __vadd4(i8s[i], TRANSFORM_SUBTRACT);\n"
"    }\n"
"    *reinterpret_cast<int4 *>(_i8s) = *reinterpret_cast<int4 *>(i8s);\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i1u_to_i8s(T1 *_i1b, T2 *_i8s, const int N = 16)\n"
"{\n"
"    int *i8s = reinterpret_cast<int *>(_i8s);\n"
"    int16_t i1b_i16 = *reinterpret_cast<int16_t *>(_i1b);\n"
"    // permutate: {e0,e4,e8,e12,e2,e6,e10,e14,e1,e5,e9,e13,e3,e7,e11,e15}\n"
"    // into: {e0,e4,e8,e12,x,x,x,x,e1,e5,e9,x,x,x,x,e13,e2,e6,e10,e14,e1,e5,"
"e9,e13,e3,e7,e11,e15,x,x,x,x}\n"
"    int i1b = (i1b_i16 & 0x0f0f);\n"
"    i1b |= ((i1b_i16 & 0xf0f0) << 12);\n"
"    // i1b        {0..,e15,e14,e13,e12,e11,e10,e9,e8,e7,e6,e5,e4,e3,e2,e1,"
"e0}\n"
"    // interleave {0..,e15,e13,e11,e9,e7,e5,e3,e1,e14,e12,e10,e8,e6,e4,e2,"
"e0}\n"
"    // First, we extract the i1b and construct an intermediate fp16 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa; // 0b11101010\n"
"    static constexpr uint BOTTOM_MASK = 0x01010101;      // 0x1 -> 0b01 "
"select 0,1\n"
"    static constexpr uint I8s_MAGIC_NUM = 0x00000000;\n"
"    static constexpr uint MEDIAN_NUM = 0x00000000;\n"
"\n"
"    for (int i = 0; i < N / 4; i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i])\n"
"                     : \"r\"(i1b >> i), \"n\"(BOTTOM_MASK), "
"\"n\"(I8s_MAGIC_NUM), \"n\"(immLut));\n"
"    }\n"
"}\n"
"\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1299
msgid ""
"\"\"\"template <typename T1, typename T2>\n"
"__device__ void decode_i2s_to_i8s(T1 *_i2b, T2 *_i8s, const int N = 16)\n"
"{\n"
"    // convert 8 int2b_t to 8 int8b_t -> 2 int32\n"
"    uint *i8s = reinterpret_cast<uint *>(_i8s);\n"
"\n"
"    // i2b = {e7,e6,e5,e4,e3,e2,e1,e0}\n"
"    // also require interleave {e7,e3,e6,e2,e5,e1,e4,e0}\n"
"    uint const i2b = *reinterpret_cast<uint *>(_i2b);\n"
"\n"
"    // First, we extract the i4s and construct an intermediate fp16 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa; // 0b11101010\n"
"    static constexpr uint BOTTOM_MASK = 0x03030303;      // 0xf -> 0b11 "
"select 0,3\n"
"    static constexpr uint I8s_MAGIC_NUM = 0x00000000;    // 1024\n"
"    static constexpr uint MEDIAN_NUM = 0x02020202;\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i])\n"
"                     : \"r\"(i2b >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(I8s_MAGIC_NUM), \"n\"(immLut));\n"
"        i8s[i] = __vsub4(i8s[i], MEDIAN_NUM);\n"
"    }\n"
"}\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i2u_to_i8s(T1 *_i2b, T2 *_i8s, const int N = 16)\n"
"{\n"
"    // convert 8 int2b_t to 8 int8b_t -> 2 int32\n"
"    uint *i8s = reinterpret_cast<uint *>(_i8s);\n"
"\n"
"    // i2b = {e7,e6,e5,e4,e3,e2,e1,e0}\n"
"    // also require interleave {e7,e3,e6,e2,e5,e1,e4,e0}\n"
"    uint const i2b = *reinterpret_cast<uint *>(_i2b);\n"
"\n"
"    // First, we extract the i4s and construct an intermediate fp16 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa; // 0b11101010\n"
"    static constexpr uint BOTTOM_MASK = 0x03030303;      // 0xf -> 0b11 "
"select 0,3\n"
"    static constexpr uint I8s_MAGIC_NUM = 0x00000000;    // 1024\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 4); i++)\n"
"    {\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i])\n"
"                     : \"r\"(i2b >> (2 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(I8s_MAGIC_NUM), \"n\"(immLut));\n"
"    }\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1363
msgid ""
"\"\"\"template <typename T1, typename T2>\n"
"__device__ void decode_i4s_to_i8s(T1 *_i4b, T2 *_i8s, const int N = 16)\n"
"{\n"
"    uint *i8s = reinterpret_cast<uint *>(_i8s);\n"
"    uint *i4b = reinterpret_cast<uint *>(_i4b);\n"
"    // First, we extract the i4s and construct an intermediate i8 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x0f0f0f0f;          // 0xf -> "
"0b1111 select 0,4,8,12\n"
"    static constexpr uint I4b_TO_I8s_MAGIC_NUM = 0x00000000; // 0\n"
"    static constexpr uint MEDIAN_NUM = 0x07070707;\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 8); i++)\n"
"    {\n"
"        // Extract elt_01 - (i4s & 0x000f000f) | 0x64006400\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i])\n"
"                     : \"r\"(i4b[0] >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(I4b_TO_I8s_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i + 2])\n"
"                     : \"r\"(i4b[1] >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(I4b_TO_I8s_MAGIC_NUM), \"n\"(immLut));\n"
"        i8s[i] = __vsubss4(i8s[i], MEDIAN_NUM);\n"
"        i8s[i + 2] = __vsubss4(i8s[i + 2], MEDIAN_NUM);\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i4u_to_i8s(T1 *_i4b, T2 *_i8s, const int N = 16)\n"
"{\n"
"    uint *i8s = reinterpret_cast<uint *>(_i8s);\n"
"    uint *i4b = reinterpret_cast<uint *>(_i4b);\n"
"    // First, we extract the i4s and construct an intermediate i8 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x0f0f0f0f;          // 0xf -> "
"0b1111 select 0,4,8,12\n"
"    static constexpr uint I4b_TO_I8s_MAGIC_NUM = 0x00000000; // 0\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 8); i++)\n"
"    {\n"
"        // Extract elt_01 - (i4s & 0x000f000f) | 0x64006400\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i])\n"
"                     : \"r\"(i4b[0] >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(I4b_TO_I8s_MAGIC_NUM), \"n\"(immLut));\n"
"\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i8s[i + 2])\n"
"                     : \"r\"(i4b[1] >> (4 * i)), \"n\"(BOTTOM_MASK), "
"\"n\"(I4b_TO_I8s_MAGIC_NUM), \"n\"(immLut));\n"
"    }\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1428
msgid ""
"\"\"\"\n"
"template <typename T1, typename T2, bool isSigned>\n"
"__device__ void decode_i2b_to_i4s(T1 *_i2b, T2 *_i4s, const int N = 16)\n"
"{\n"
"    uint *i4s = reinterpret_cast<uint *>(_i4s);\n"
"    uint *i2b = reinterpret_cast<uint *>(_i2b);\n"
"    // First, we extract the i4s and construct an intermediate i8 number.\n"
"    static constexpr uint immLut = (0xf0 & 0xcc) | 0xaa;\n"
"    static constexpr uint BOTTOM_MASK = 0x33333333;          // 0xf -> "
"0b1111 select 0,2,4,6,8,10,12\n"
"    static constexpr uint I4b_TO_I8s_MAGIC_NUM = 0x00000000; // 0\n"
"    static constexpr uint MEDIAN_NUM = isSigned ? 0x33333333 : 0x00000000;\n"
"\n"
"#pragma unroll\n"
"    for (int i = 0; i < (N / 8); i++)\n"
"    {\n"
"        // Extract elt_01 - (i4s & 0x000f000f) | 0x64006400\n"
"        asm volatile(\"lop3.b32 %0, %1, %2, %3, %4;\\n\"\n"
"                     : \"=r\"(i4s[i])\n"
"                     : \"r\"(i2b[i / 2] >> (2 * (i % 2))), "
"\"n\"(BOTTOM_MASK), \"n\"(I4b_TO_I8s_MAGIC_NUM), \"n\"(immLut));\n"
"        if constexpr (isSigned)\n"
"        {\n"
"            // TODO(lei): uint4 sub should be enhanced.\n"
"            // 0x03 0x03 0x03 0x03\n"
"            // i4s[i] = (((i4s[i] << 1) | i4s[i]) << 1) | i4s[i];\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i2s_to_i4s(T1 *_i4s, T2 *B_local_decode, const int N "
"= 16)\n"
"{\n"
"    decode_i2b_to_i4s<T1, T2, true>(_i4s, B_local_decode, N);\n"
"}\n"
"\n"
"template <typename T1, typename T2>\n"
"__device__ void decode_i2u_to_i4s(T1 *_i4u, T2 *B_local_decode, const int N "
"= 16)\n"
"{\n"
"    decode_i2b_to_i4s<T1, T2, false>(_i4u, B_local_decode, N);\n"
"}\n"
"\"\"\""
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1479
msgid ""
"This function is used to get the intrinsic group of the LOP3 operation to "
"avoid the overhead of fast decoding. LOP3 is a type of logic operation that "
"takes three inputs. The intrinsic group refers to the set of intrinsic "
"operations that can be performed on these inputs. This function retrieves "
"and returns this group."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:0
msgid "Parameters"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1483
msgid "The data type of the input. It should be \"int8\"."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1485
msgid ""
"The data type of the output. It can be either \"float16\" or \"int8\" or "
"\"int4\"."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1487
msgid "The number of bits used for storage. By default, it is 4."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1489
msgid ""
"A boolean parameter that indicates whether scaling should be applied. By "
"default, it is False."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1491
msgid ""
"A boolean parameter that indicates whether zeros should be used. By default, "
"it is False."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1493
msgid ""
"The mode of zeros. It can be either \"original\", \"rescale\", or "
"\"quantized\". By default, it is \"original\"."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1495
msgid ""
"The scope of the storage. It can be either \"local\" or \"warp\". By "
"default, it is \"local\"."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:0
msgid "Returns"
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:1498
msgid ""
"A dictionary mapping the names of the intrinsics to their corresponding "
"implementations."
msgstr ""

#: ../../../autoapi/tilelang/quantize/lop3/index.rst:0
msgid "Return type"
msgstr ""
