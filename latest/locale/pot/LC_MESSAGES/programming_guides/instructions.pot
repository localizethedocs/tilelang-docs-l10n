# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025-2025, Tile Lang Contributors
# This file is distributed under the same license as the TileLang <br> package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TileLang <br> latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-02 08:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../programming_guides/instructions.md:1
msgid "Instructions"
msgstr ""

#: ../../../programming_guides/instructions.md:3
msgid ""
"This page summarizes the core TileLang “instructions” available at the DSL "
"level, how they map to hardware concepts, and how to use them correctly."
msgstr ""

#: ../../../programming_guides/instructions.md:6
msgid "Quick Categories"
msgstr ""

#: ../../../programming_guides/instructions.md:7
msgid ""
"Data movement: `T.copy`, `T.c2d_im2col`, staging Global ↔ Shared ↔ Fragment"
msgstr ""

#: ../../../programming_guides/instructions.md:8
msgid ""
"Compute primitives: `T.gemm`/`T.gemm_sp`, elementwise math (`T.exp`, `T."
"max`), reductions (`T.reduce_sum`, `T.cumsum`, warp reducers)"
msgstr ""

#: ../../../programming_guides/instructions.md:10
msgid "Control helpers: `T.clear`/`T.fill`, `T.reshape`/`T.view`"
msgstr ""

#: ../../../programming_guides/instructions.md:11
msgid "Diagnostics: `T.print`, `T.device_assert`"
msgstr ""

#: ../../../programming_guides/instructions.md:12
msgid "Advanced: atomics, memory barriers, warp‑group ops"
msgstr ""

#: ../../../programming_guides/instructions.md:14
msgid "Data Movement"
msgstr ""

#: ../../../programming_guides/instructions.md:16
msgid ""
"Use `T.copy(src, dst, *, coalesced_width=None, disable_tma=False, "
"eviction_policy=None, loop_layout=None)` to move tiles between memory "
"scopes. It accepts `tir.Buffer`, `BufferLoad`, or `BufferRegion`; extents "
"are inferred or broadcast when possible."
msgstr ""

#: ../../../programming_guides/instructions.md:20
msgid ""
"# Global → Shared tiles (extents inferred from dst)\n"
"T.copy(A[by * BM, ko * BK], A_s)\n"
"T.copy(B[ko * BK, bx * BN], B_s)\n"
"\n"
"# Fragment/Register → Global (store result)\n"
"T.copy(C_f, C[by * BM, bx * BN])\n"
msgstr ""

#: ../../../programming_guides/instructions.md:29
msgid "Semantics"
msgstr ""

#: ../../../programming_guides/instructions.md:30
msgid ""
"Extents are deduced from arguments; missing sides broadcast to the other’s "
"rank."
msgstr ""

#: ../../../programming_guides/instructions.md:31
msgid ""
"Access patterns are legalized and coalesced during lowering. Explicit "
"vectorization is not required in HL mode."
msgstr ""

#: ../../../programming_guides/instructions.md:33
msgid ""
"Safety: the LegalizeSafeMemoryAccess pass inserts boundary guards when an "
"access may be out‑of‑bounds and drops them when proven safe."
msgstr ""

#: ../../../programming_guides/instructions.md:36
msgid "Other helpers"
msgstr ""

#: ../../../programming_guides/instructions.md:37
msgid "`T.c2d_im2col(img, col, ...)`: convenience for conv‑style transforms."
msgstr ""

#: ../../../programming_guides/instructions.md:39
msgid "Compute Primitives"
msgstr ""

#: ../../../programming_guides/instructions.md:41
msgid "GEMM and sparse GEMM"
msgstr ""

#: ../../../programming_guides/instructions.md:42
msgid ""
"`T.gemm(A_shared, B_shared, C_fragment)`: computes a tile GEMM using shared "
"inputs and a fragment accumulator; lowered to target‑specific tensor cores."
msgstr ""

#: ../../../programming_guides/instructions.md:44
msgid ""
"`T.gemm_sp(...)`: 2:4 sparse tensor core variant (see examples and README)."
msgstr ""

#: ../../../programming_guides/instructions.md:46
msgid "Reductions and scans"
msgstr ""

#: ../../../programming_guides/instructions.md:47
msgid ""
"`T.reduce_sum`, `T.reduce_max`, `T.reduce_min`, `T.cumsum`, plus warp "
"reducers (`T.warp_reduce_sum`, etc.)."
msgstr ""

#: ../../../programming_guides/instructions.md:49
msgid ""
"Allocate and initialize accumulators via `T.alloc_fragment` + `T.clear` or "
"`T.fill`."
msgstr ""

#: ../../../programming_guides/instructions.md:52
msgid "Elementwise math"
msgstr ""

#: ../../../programming_guides/instructions.md:53
msgid ""
"Most math ops mirror TVM TIR: `T.exp`, `T.log`, `T.max`, `T.min`, `T.rsqrt`, "
"`T.sigmoid`, etc. Compose freely inside loops."
msgstr ""

#: ../../../programming_guides/instructions.md:56
msgid "Reshape/view (no copy)"
msgstr ""

#: ../../../programming_guides/instructions.md:57
msgid ""
"`T.reshape(buf, new_shape)` and `T.view(buf, shape=None, dtype=None)` create "
"new views that share storage, with shape/dtype checks enforced."
msgstr ""

#: ../../../programming_guides/instructions.md:60
msgid "Synchronization (HL usage)"
msgstr ""

#: ../../../programming_guides/instructions.md:62
msgid ""
"In HL pipelines, you usually don’t need to write explicit barriers. Passes "
"such as PipelinePlanning/InjectSoftwarePipeline/InjectTmaBarrier orchestrate "
"producer/consumer ordering and thread synchronization behind the scenes."
msgstr ""

#: ../../../programming_guides/instructions.md:66
msgid "If you need debugging or explicit checks:"
msgstr ""

#: ../../../programming_guides/instructions.md:67
msgid ""
"`T.device_assert(cond, msg='')` emits device‑side asserts on CUDA targets."
msgstr ""

#: ../../../programming_guides/instructions.md:68
msgid ""
"`T.print(obj, msg='...')` prints scalars or buffers safely from one thread."
msgstr ""

#: ../../../programming_guides/instructions.md:70
msgid "Putting It Together: GEMM Tile"
msgstr ""

#: ../../../programming_guides/instructions.md:72
msgid ""
"@T.prim_func\n"
"def gemm(\n"
"    A: T.Tensor((M, K), 'float16'),\n"
"    B: T.Tensor((K, N), 'float16'),\n"
"    C: T.Tensor((M, N), 'float16'),\n"
"):\n"
"    with T.Kernel(T.ceildiv(N, BN), T.ceildiv(M, BM), threads=128) as (bx, "
"by):\n"
"        A_s = T.alloc_shared((BM, BK), 'float16')\n"
"        B_s = T.alloc_shared((BK, BN), 'float16')\n"
"        C_f = T.alloc_fragment((BM, BN), 'float32')\n"
"        T.clear(C_f)\n"
"\n"
"        for ko in T.Pipelined(T.ceildiv(K, BK), num_stages=3):\n"
"            T.copy(A[by * BM, ko * BK], A_s)  # Global → Shared\n"
"            T.copy(B[ko * BK, bx * BN], B_s)\n"
"            T.gemm(A_s, B_s, C_f)             # compute into fragment\n"
"\n"
"        T.copy(C_f, C[by * BM, bx * BN])      # store back\n"
msgstr ""

#: ../../../programming_guides/instructions.md:93
msgid "Instruction Reference (Concise)"
msgstr ""

#: ../../../programming_guides/instructions.md:95
msgid ""
"Below is a concise list of TileLang instructions grouped by category. For "
"full signatures, behaviors, constraints, and examples, refer to API "
"Reference (`autoapi/tilelang/index`)."
msgstr ""

#: ../../../programming_guides/instructions.md:99
msgid "Data movement"
msgstr ""

#: ../../../programming_guides/instructions.md:100
msgid "`T.copy(src, dst, ...)`: Move tiles between Global/Shared/Fragment."
msgstr ""

#: ../../../programming_guides/instructions.md:101
msgid "`T.c2d_im2col(img, col, ...)`: 2D im2col transform for conv."
msgstr ""

#: ../../../programming_guides/instructions.md:103
msgid "Memory allocation and descriptors"
msgstr ""

#: ../../../programming_guides/instructions.md:104
msgid ""
"`T.alloc_shared(shape, dtype, scope='shared.dyn')`: Allocate shared buffer."
msgstr ""

#: ../../../programming_guides/instructions.md:105
msgid ""
"`T.alloc_fragment(shape, dtype, scope='local.fragment')`: Allocate fragment."
msgstr ""

#: ../../../programming_guides/instructions.md:106
msgid ""
"`T.alloc_var(dtype, [init], scope='local.var')`: Scalar var buffer (1 elem)."
msgstr ""

#: ../../../programming_guides/instructions.md:107
msgid ""
"`T.alloc_barrier(arrive_count)`: Allocate and initialize one or more "
"mbarriers."
msgstr ""

#: ../../../programming_guides/instructions.md:108
msgid "`T.alloc_tmem(shape, dtype)`: Tensor memory (TMEM) buffer (Hopper+)."
msgstr ""

#: ../../../programming_guides/instructions.md:109
msgid ""
"`T.alloc_reducer(shape, dtype, op='sum', replication=None)`: Reducer buf."
msgstr ""

#: ../../../programming_guides/instructions.md:110
msgid "`T.alloc_descriptor(kind, dtype)`: Generic descriptor allocator."
msgstr ""

#: ../../../programming_guides/instructions.md:111
msgid "`T.alloc_wgmma_desc(dtype='uint64')`"
msgstr ""

#: ../../../programming_guides/instructions.md:112
msgid "`T.alloc_tcgen05_smem_desc(dtype='uint64')`"
msgstr ""

#: ../../../programming_guides/instructions.md:113
msgid "`T.alloc_tcgen05_instr_desc(dtype='uint32')`"
msgstr ""

#: ../../../programming_guides/instructions.md:114
msgid "`T.empty(shape, dtype='float32')`: Declare function output tensors."
msgstr ""

#: ../../../programming_guides/instructions.md:116
msgid "Compute primitives"
msgstr ""

#: ../../../programming_guides/instructions.md:117
msgid "`T.gemm(A_s, B_s, C_f)`: Tile GEMM into fragment accumulator."
msgstr ""

#: ../../../programming_guides/instructions.md:118
msgid "`T.gemm_sp(...)`: Sparse (2:4) tensor core GEMM."
msgstr ""

#: ../../../programming_guides/instructions.md:119
msgid "Reductions: `T.reduce_sum/max/min/abssum/absmax`, bitwise `and/or/xor`."
msgstr ""

#: ../../../programming_guides/instructions.md:120
msgid "Scans: `T.cumsum`, finalize: `T.finalize_reducer`."
msgstr ""

#: ../../../programming_guides/instructions.md:121
msgid "Warp reducers: `T.warp_reduce_sum/max/min/bitand/bitor`."
msgstr ""

#: ../../../programming_guides/instructions.md:122
msgid ""
"Elementwise math: TIR ops (`T.exp`, `T.log`, `T.max`, `T.min`, `T."
"rsqrt`, ...)."
msgstr ""

#: ../../../programming_guides/instructions.md:123
msgid ""
"Fast math: `T.__log/__log2/__log10/__exp/__exp2/__exp10/__sin/__cos/__tan`."
msgstr ""

#: ../../../programming_guides/instructions.md:124
msgid "IEEE math: `T.ieee_add/sub/mul/fmaf` (configurable rounding)."
msgstr ""

#: ../../../programming_guides/instructions.md:125
msgid "Helpers: `T.clear(buf)`, `T.fill(buf, value)`."
msgstr ""

#: ../../../programming_guides/instructions.md:126
msgid "Views: `T.reshape(buf, shape)`, `T.view(buf, shape=None, dtype=None)`."
msgstr ""

#: ../../../programming_guides/instructions.md:128
msgid "Diagnostics"
msgstr ""

#: ../../../programming_guides/instructions.md:129
msgid "`T.print(obj, msg='')`: Print scalar/buffer from one thread."
msgstr ""

#: ../../../programming_guides/instructions.md:130
msgid "`T.device_assert(cond, msg='')`: Device-side assert (CUDA)."
msgstr ""

#: ../../../programming_guides/instructions.md:132
msgid "Logical helpers"
msgstr ""

#: ../../../programming_guides/instructions.md:133
msgid "`T.any_of(a, b, ...)`, `T.all_of(a, b, ...)`: Multi-term predicates."
msgstr ""

#: ../../../programming_guides/instructions.md:135
msgid "Annotation helpers"
msgstr ""

#: ../../../programming_guides/instructions.md:136
msgid "`T.use_swizzle(panel_size=..., enable=True)`: Rasterization hint."
msgstr ""

#: ../../../programming_guides/instructions.md:137
msgid "`T.annotate_layout({...})`: Attach explicit layouts to buffers."
msgstr ""

#: ../../../programming_guides/instructions.md:138
msgid "`T.annotate_safe_value(var, ...)`: Safety/const hints."
msgstr ""

#: ../../../programming_guides/instructions.md:139
msgid "`T.annotate_l2_hit_ratio(buf, ratio)`: Cache behavior hint."
msgstr ""

#: ../../../programming_guides/instructions.md:141
msgid "Synchronization helpers"
msgstr ""

#: ../../../programming_guides/instructions.md:142
msgid ""
"`T.pdl_trigger()`: Signal programmatic launch completion for the current "
"kernel."
msgstr ""

#: ../../../programming_guides/instructions.md:143
msgid "`T.pdl_sync()`: Wait until kernel dependencies are satisfied."
msgstr ""

#: ../../../programming_guides/instructions.md:145
msgid "Atomics"
msgstr ""

#: ../../../programming_guides/instructions.md:146
msgid ""
"`T.atomic_add(dst, value, memory_order=None, return_prev=False, "
"use_tma=False)`."
msgstr ""

#: ../../../programming_guides/instructions.md:147
msgid "`T.atomic_addx2(dst, value, return_prev=False)`; `T.atomic_addx4(...)`."
msgstr ""

#: ../../../programming_guides/instructions.md:148
msgid "`T.atomic_max(dst, value, memory_order=None, return_prev=False)`."
msgstr ""

#: ../../../programming_guides/instructions.md:149
msgid "`T.atomic_min(dst, value, memory_order=None, return_prev=False)`."
msgstr ""

#: ../../../programming_guides/instructions.md:150
msgid "`T.atomic_load(dst)`, `T.atomic_store(dst, value)`."
msgstr ""

#: ../../../programming_guides/instructions.md:152
msgid "Custom intrinsics"
msgstr ""

#: ../../../programming_guides/instructions.md:153
msgid "`T.dp4a(A, B, C)`: 4‑element dot‑product accumulate."
msgstr ""

#: ../../../programming_guides/instructions.md:154
msgid "`T.clamp(x, lo, hi)`: Clamp to [lo, hi]."
msgstr ""

#: ../../../programming_guides/instructions.md:155
msgid "`T.loop_break()`: Break from current loop via intrinsic."
msgstr ""

#: ../../../programming_guides/instructions.md:157
msgid "Barriers, TMA, warp‑group"
msgstr ""

#: ../../../programming_guides/instructions.md:158
msgid "Barriers: `T.alloc_barrier(arrive_count)`."
msgstr ""

#: ../../../programming_guides/instructions.md:159
msgid ""
"Parity ops: `T.mbarrier_wait_parity(barrier, parity)`, `T."
"mbarrier_arrive(barrier)`."
msgstr ""

#: ../../../programming_guides/instructions.md:160
msgid ""
"Expect tx: `T.mbarrier_expect_tx(...)`; sugar: `T.barrier_wait(id, "
"parity=None)`."
msgstr ""

#: ../../../programming_guides/instructions.md:161
msgid ""
"TMA: `T.create_tma_descriptor(...)`, `T.tma_load(...)`, `T."
"tma_store_arrive(...)`, `T.tma_store_wait(...)`."
msgstr ""

#: ../../../programming_guides/instructions.md:163
msgid ""
"Proxy/fences: `T.fence_proxy_async(...)`, `T.warpgroup_fence_operand(...)`."
msgstr ""

#: ../../../programming_guides/instructions.md:164
msgid ""
"Warp‑group: `T.warpgroup_arrive()`, `T.warpgroup_commit_batch()`, `T."
"warpgroup_wait(num_mma)`, `T.wait_wgmma(id)`."
msgstr ""

#: ../../../programming_guides/instructions.md:167
msgid "Lane/warp index"
msgstr ""

#: ../../../programming_guides/instructions.md:168
msgid "`T.get_lane_idx(warp_size=None)`: Lane id in warp."
msgstr ""

#: ../../../programming_guides/instructions.md:169
msgid "`T.get_warp_idx_sync(warp_size=None)`: Canonical warp id (sync)."
msgstr ""

#: ../../../programming_guides/instructions.md:170
msgid "`T.get_warp_idx(warp_size=None)`: Canonical warp id (no sync)."
msgstr ""

#: ../../../programming_guides/instructions.md:171
msgid "`T.get_warp_group_idx(warp_size=None, warps_per_group=None)`: Group id."
msgstr ""

#: ../../../programming_guides/instructions.md:173
msgid "Register control"
msgstr ""

#: ../../../programming_guides/instructions.md:174
msgid ""
"`T.set_max_nreg(reg_count, is_inc)`, `T.inc_max_nreg(n)`, `T."
"dec_max_nreg(n)`."
msgstr ""

#: ../../../programming_guides/instructions.md:175
msgid ""
"`T.annotate_producer_reg_dealloc(n=24)`, `T."
"annotate_consumer_reg_alloc(n=240)`."
msgstr ""

#: ../../../programming_guides/instructions.md:176
msgid "`T.no_set_max_nreg()`, `T.disable_warp_group_reg_alloc()`."
msgstr ""

#: ../../../programming_guides/instructions.md:178
msgid "Notes on Dtypes"
msgstr ""

#: ../../../programming_guides/instructions.md:180
msgid "Dtypes accept three equivalent forms:"
msgstr ""

#: ../../../programming_guides/instructions.md:181
msgid "String: `'float32'`"
msgstr ""

#: ../../../programming_guides/instructions.md:182
msgid "TileLang dtype: `T.float32`"
msgstr ""

#: ../../../programming_guides/instructions.md:183
msgid ""
"Framework dtype: `torch.float32` All are normalized internally. See Type "
"System for details."
msgstr ""
